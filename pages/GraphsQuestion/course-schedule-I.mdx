---
title: "Course Schedule"
---

import { useState } from 'react';

# 📚 Course Schedule

Determine if it is possible to finish all courses given a list of course prerequisites.

## 📝 Problem Description

You are given:
- An integer `numCourses` representing the total number of courses you have to take, labeled from `0` to `numCourses-1`.
- An array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before taking course `ai`.

### 🚀 Goal

Return `true` if you can finish all courses, otherwise return `false`.

## 🔢 Input

- `numCourses` (integer): The total number of courses.
- `prerequisites` (array of pairs): Each pair `[a, b]` indicates that to take course `a`, you must first take course `b`.

## 📤 Output

- Return `true` if you can finish all courses, otherwise return `false`.

## 🌟 Examples

### Example 1

### Input
```cpp
{
  "numCourses": 2,
  "prerequisites": [[1, 0]]
}
```
### Output
```cpp
  False
```

## Initial State

- `numCourses = 2`
- `prerequisites = [[1, 0]]`

## Graph Representation

Courses: `[0, 1]`
Prerequisites:
- `1 -> 0`

## Topological Sorting Check

Start with courses that have no prerequisites:
- Course `0` has no prerequisites.
- Take course `0`.
- After taking `0`, course `1` can be taken (since `1 -> 0`).

## Conclusion

- All courses can be completed in the given order: `[0, 1]`.
- Output: `true`
### Example 2
## Input

```cpp
{
  "numCourses": 4,
  "prerequisites": [[1, 0], [2, 1], [3, 2], [1, 3]]
}
```
## Output
```cpp
true
```
## Initial State

- `numCourses = 4`
- `prerequisites = [[1, 0], [2, 1], [3, 2], [1, 3]]`

## Graph Representation

Courses: `[0, 1, 2, 3]`
Prerequisites:
- `1 -> 0`
- `2 -> 1`
- `3 -> 2`
- `1 -> 3`

## Topological Sorting Check

Start with courses that have no prerequisites:
- Course `0` has no prerequisites.
- Take course `0`.
- After taking `0`, course `1` can be taken (since `1 -> 0`).
- After taking `1`, course `2` can be taken (since `2 -> 1`).
- After taking `2`, course `3` can be taken (since `3 -> 2`).
- After taking `3`, course `1` can be taken again (since `1 -> 3`).

## Conclusion

- All courses can be completed in the given order: `[0, 1, 2, 3]`.
- Output: `true`

## Solution: Conquering Prerequisites with Kahn's Algorithm**

This solution leverages **Kahn's algorithm**, a powerful technique for finding a topological sort in a directed acyclic graph (DAG). Here's how it works:

1. **Represent Courses and Prerequisites:**
   - Create an **adjacency list**, where each course is a key and its corresponding values represent courses that require it as a prerequisite.

2. **Calculate In-Degrees:**
   - For each course, track the number of incoming prerequisite edges (in-degree). Courses with no prerequisites have an in-degree of 0.

3. **Identify Courses Without Prerequisites:**
   - Create a queue and add all courses with an in-degree of 0. These are the starting points for your schedule because you can take them immediately.

4. **Iteratively Remove Courses and Update In-Degrees:**
   - While the queue is not empty:
     - Remove the first course (let's call it `currentCourse`) from the queue.
     - For each course that has `currentCourse` as a prerequisite:
       - Decrement its in-degree.
       - If the in-degree becomes 0, add that course to the queue, indicating it's ready to be scheduled.

5. **Check for Completion or Cycle:**
   - If, after processing all courses, the queue is empty and there are still unprocessed courses, it signifies a cycle in the prerequisites, meaning a valid schedule doesn't exist.
   - If the queue processed all courses, then you've successfully found a topological sort, representing a valid course schedule.


```cpp
//code: finding toplogical sort using kahns algorithm
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        unordered_map<int,vector<int> > adj;
        for(int i=0;i<prerequisites.size();i++){
            int u=prerequisites[i][1];
            int v=prerequisites[i][0];
            adj[u].push_back(v);        
        }
        ///// create indegree
        vector<int> inDeg(numCourses,0);
        for(int i=0;i<numCourses;i++){
            for(int j: adj[i]){
                inDeg[j]+=1;
            }
        }
        //// create a queue and push all element with indegree 0
        queue<int> q;
        for(int i=0;i<numCourses;i++){
            if(inDeg[i]==0){
                q.push(i);
            }
        }

        ///// do bfs
        vector<int> answer;
        while(!q.empty()){
            int temp=q.front();
            q.pop();
            answer.push_back(temp);
            for(auto i : adj[temp]){
                inDeg[i]--;
                if(inDeg[i]==0){
                    q.push(i);
                }
            }
        }
        if(answer.size()==numCourses){
            return true;
        }
        else{
            return false;
        }
        // for(int i=0;i<numCourses;i++){
        //     if(inDeg[i]!=0){
        //         return false;
        //     }
        // }
        // return true;
    }
};